# 250204_OOP2_강의

# 상속(Inheritance)
- 한 클래스(부모)의 속성과 메서드를 다른 클래스(자식)가 물려받는 것

    ## 상속이 필요한 이유?
    1. 코드 재사용
        - 상속을 통해 기존 클래스ㅡ이 속성과 메서드를 재사용할 수 있음
        - 기존 클래스를 수정하지 않고도 기능을 확장할 수 있음
    
    2. 계층 구조
        - 상속을 통해 클래스들 간의 계층 구조를 형성할 수 있음
        - 부모 클래스와 자식 클래스 간의 관계를 표현하고, 더 구체적인 클래스를 만들 수 있음
    
    3. 유지 보수의 용이성
        - 상속을 통해 기존 클래스의 수정이 필요한 경우, 해당 클래스만 수정하면 되므로 유지 보수가 용이해짐
        - 코드의 일관성을 유지하고, 수정이 필요한 범위를 최소화 할 수 있음
    
    ## 상속 없이 구현 하는 경우
    - 학생/교수 정보를 별도로 표현하기 어려움
    ![alt text](image_0204.png)
    
    - 교수/학생 클래스로 분리 했짐나 메서드가 중복으로 정의될 수 있음
    ![alt text](image1_0204.png)

---

# 오버라이딩
- 부모 클래스의 메서드를 같은 이름, 같은 파라미터 구조로 재정의하는 것

    ## 예시
    - 자식 클래스가 부모 클래스의 메서드를 덮어 새로운 동작을 구현
    ![alt text](image2_0204.png)

# 오버로딩
- 같은 이름, 다른 파라미터를 가진 여러 메서드를 정의하는 것(파이썬은 미지원)
- 파이썬은 실제로 하나의 메서드만 인식하며, 인자의 형태가 다르다는 이유로 메서드를 여러 개 구분하여 불러주지 않음

---

# 다중 상속
- 둘 이상의 상위 클래스로부터 여러 행동이나 특징을 상속받을 수 있는것
- 상속받은 모든 클래스의 요소를 활용 가능함
- 중복된 속성이나 메서드가 있는 경우 상속 순서에 의해 결정됨

    ## 다이아몬드 문제
    - 두 클래스 B와 C가 A에서 상속되고 클래스 D가 B와 C 모두에서 상속될 때 발생하는 모호함
    - B와 C가 재정의한 메서드가 A에 있고 D가 이를 재정의하지 않은 경우라면 
        => D는 B의 메서드 중 어떤 버전을 상속하는가? 아니면 C의 메서드 버전을 상속하는가?
    
    ### 파이썬에서의 해결책
    ※ MRO - 파이썬이 메서드를 찾는 순서에 대한 규칙, 메서드 결정 순서

    - MRO(Method Resolution Order) 알고리즘을 사용하여 클래스 목록을 생성
    - 부모 클래스로부터 상속된 속성들의 검색을 깊이 우선으로, 왼쪽에서 오른쪽으로, 계층 구조에서 겹치는 같은 클래스를 두 번 검색하지 않음
    - 그래서, 속성이 D에서 발견되지 않으면, B에서 찾고, 거기에서도 발견되지 않으면 C에서 찾고 이런식으로 진행됨

    ### super()
    - 부모 클래스(또는 상위 클래스)의 메서드를 호출하기 위해 사용하는 내장 함수

        #### 기능
        - 다중 상속 상황에서 특히 유용, MRO를 따르기 때문에 여러 부모 클래스를 가진 자식 클래스에서 다음에 호출해야 할 부모 메서드를 순서대로 호출할 수 있게 함

        #### 2가지 예시
        1. 단일 상속 구조
            - 명시적으로 이름을 지정하지 않고 부모 클래스를 참조할 수 있으므로, 코드를 더 유지 관리하기 쉽게 만들 수 있음
            - 클래스 이름이 변경되거나 부모 클래스가 교체되어도 super()를 사용하면 코드 수정이 더 적게 필요
        
        2. 다중 상속 구조
            - MRO를 따른 메서드 호출
            - 복잡한 다중 상속 구조에서 발생할 수 있는 문제를 방지
        
        #### 이점
        - 다중 상속 상황에서 super()는 다음에 호출해야 할 부모 메서드를 MRO 순서에 따라 결정하기 때문에, 명시적으로 특정 부모 클래스를 가리키지 않고도 올바른 순서로 부모 초기화나 메서드 호출이 가능
        - 이를 통해 복잡한 상속 구조에서도 코드를 유연하고 깔끔하게 유지할 수 있음

        #### 정리
        - super()를 사용할 때는 MRO를 잘 이해하고 있어야함
        - Classname.__mro__ 또는 ClassName.mro()를 확인해 MRO 순서를 파악한 뒤, 적절히 활용하는 연습을 하면, 보다 복잡한 상속 구조에서도 코드를 잘 관리할 수 있음

        #### MRO가 필요한 이유
        - 부모 클래스들이 여러 번 액세스 되지 않도록, 각 클래스에서 지정된 왼쪽에서 오른쪽으로 가는 순서를 보존하고, 각 부모를 오직 한 번만 호출하고, 부모들의 우선순위에 영향을 주지 않으면서 서브 클래스를 만드는 단조적인 구조 형성

---

# 에러와 예외

## 버그
- 소프트웨어에서 발생하는 오류 또는 결함, 프로그램의 예상된 동작과 실제 동작 사이의 불일치

## 디버깅
- 버그를 찾아내고 수정하는 과정, 프로그램의 오작동 원인을 식별하여 수정하는 작업

    ### 방법
    1. print 함수 활용
    2. 개발 환경(text editor, IDE) 등에서 제공하는 기능 활용
    3. Python tutor활용(단순 파이썬 코드인 경우)
    4. 뇌 컴파일, 눈 디버깅

## 에러
- 프로그램 실행 중에 발생하는 예외 상황

    ### 문법 에러 Syntax Error
    - 프로그램의 구문이 올바르지 않은 경우 발생(오타, 괄호 및 콜론 누락 등 문법적 오류)

    ### 예외 Exception
    - 프로그램 실행 중에 감지되는 에러

        #### 내장 예외
        - 예외 상황을 나타내는 예외 클래스들

    ### 예외처리
    - 예외가 발생했을 때 프로그램이 비정상적으로 종료되지 않고, 적절하게 처리할 수 있도록 하는 방법
        
        #### 구문
        - try 
            - 예외가 발생할 수 있는 코드 작성
        - except
            - 예외가 발생했을 때 실행할 코드 작성
        - else 
            - 예외가 발생하지 않았을 때 실행할 코드 작성
        - finally

        #### 내장 예외의 상속 계층구조 주의
        - 아래와 같이 예외를 작성하면 코드는 2번째 except 절에 이후로 도달하지 못함
        ![예외오류](image3_0204.png)
        - 내장 예외 클래스는 상속 계층구조를 가지기 때문에 except절로 분기 시 반드시 하위 클래스를 먼저 확인 할 수 있도록 작성해야 함

    ### 예외 객체 다루기
    1. as 키워드
    - 예외 객체 
        - 예외가 발생했을 때 예외에 대한 정보를 담고 있는 객체
    - except 블록에서 예외 객체를 받아 상세한 예외 정보를 활용 가능
    
    2. try-except와 if-else를 함께 사용할 수 있음

    ### EAFP
    - Easier to Ask for Forgiveness than Permission
    - 예외처리를 중심으로 코드를 작성하는 접근 방식(try-except)

    ## LBYL
    - Look Before You Leap
    - 값 검사를 중심으로 코드를 작성하는 접근 방식(if-else)